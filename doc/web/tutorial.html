<!DOCTYPE HTML>
<html>
<head>
	<meta charset="UTF-8">
	<title>libunittest C++ library</title>
	<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body>
	<div id="header">
		<div>
			<ul id="navigation">
				<li>
					<a href="index.html">Home</a>
				</li>
				<li>
					<a href="installation.html">Installation</a>
				</li>
				<li class="active">
					<a href="tutorial.html">Tutorial</a>
				</li>
				<li>
					<a href="downloads.html">Downloads</a>
				</li>
				<li>
					<a href="feedback.html">Feedback</a>
				</li>
			</ul>
		</div>
	</div>
	<div id="contents">
			<h1>Tutorial</h1>
				<p> This tutorial provides you with a quick 
				introduction to libunittest. Note that this tutorial reflects the state of the 
                <a href="http://sourceforge.net/projects/libunittest/files/latest/download?source=files" target="_blank">latest version</a>				
				of libunittest. Please also check out 
				the <a href="http://sourceforge.net/p/libunittest/code/ci/master/tree/examples/" target="_blank">examples</a> 
				and <a href="http://sourceforge.net/p/libunittest/code/ci/master/tree/test/" target="_blank">unit tests</a> 
				that are shipped with libunittest. </p>
			
				<p>
				<li>
					<a href="#assembling">Assembling a test project</a>
				</li>
				<li>
					<a href="#assertions">Assertions</a>
				</li>
				<li>
					<a href="#random">Random values and containers</a>
				</li>
				<li>
					<a href="#output">Customizing output</a>
				</li>
				<li>
					<a href="#miscellaneous">Miscellaneous</a>
				</li>
				<li>
					<a href="#developer">Developer notes</a>
				</li>
				</p>
			
				<a name="assembling"></a>
                <h2>Assembling a test project</h2>
                <p>
                The first thing you'll need is a <incode>main.cpp</incode> file 
                which should look like this:
                <code>
                    // main.cpp <br>
                    #include &lt;libunittest/unittest.hpp&gt;<br></br>
                    int main(int argc, char **argv)<br> 
                    {<br>
                    <t>return unittest::process(argc, argv);</t><br>
                    }
                </code>
                Everything coming from libunittest lives within the 
                <incode>unittest</incode> namespace. There are different ways
                of writing tests with libunittest depending on your needs
                and requirements. The simplest way to do it would be to define 
                a source file like this:
                <code>
                    // test_simple.cpp<br>
                    #include &lt;libunittest/unittest.hpp&gt;<br>
                    #include &lt;libunittest/shortcuts.hpp&gt;<br></br>

                    TEST(test_value_is_true)<br>
                    {<br>
                        <t>assert_true(true, SPOT);</t><br>
                    }<br><br>
                                        
                    struct fixture {<br>
                        <t>int value;</t><br>
                        <t>fixture() : value(42) {}</t><br>
                    }; <br><br>
    
                    TEST_FIXTURE(fixture, test_with_fixture)<br>
                    {<br>
                        <t>assert_equal(42, value, SPOT);</t><br>
                    }<br><br>
                                        
                </code>
				All macros are defined in 
				capital letters and can be found in <incode>libunittest/macros.hpp</incode>. Shorter aliases (such as <incode>TEST</incode>)
				are defined in <incode>libunittest/shortcuts.hpp</incode>.
				The macro <incode>SPOT</incode> (<incode>UNITTEST_SPOT</incode>)
				defines a simple string containing information about 
				the current file and line number.
                </p>
                <p>
                Note that the above example is only one way of writing tests
                with libunittest. Another way would be to define explicit
                test classes which leads to more flexibility and faster compile
                times. It is usually recommended for larger test projects. An example of using explicit test
                classes can be found <a href="http://sourceforge.net/p/libunittest/code/ci/master/tree/examples/flexible/" target="_blank">here</a>. 
                </p>
                <p>
                In order to compile the above example it is assumed 
                that libunittest is installed and present in the respective
                environment variables. In order to compile on Linux-like systems 
                using <incode>g++(&ge;4.7)</incode>, you can do:
                <code>
                g++ -std=c++0x -pthread main.cpp test_simple.cpp -lunittest -o unittest.exe
                </code>
                Doing <incode>./unittest.exe -v</incode> &nbsp; gives the following output:
                <code>
                test_value_is_true ... ok<br>
                test_with_fixture ... ok<br><br>
                
                --------------------------------------------------<br>
                Ran 2 tests in 0.000334s<br><br>
                
                OK
                </code>
                To get a quick help to your testing application just do
                <incode>./unittest.exe -h</incode>:
                <code>
                This is your testing application using libunittest-3.7.0<br><br>
                
                Usage: ./unittest.exe [Options]<br><br>
                
                Options:<br>
                -h &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Displays this help message<br>
                -v &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sets verbose output for running tests<br>
                -s &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stops running tests after the first test fails<br>
                -e &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Turns off handling of unexpected exceptions<br>
                -x &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enables the generation of the XML output<br>
                -d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A dry run without actually executing any tests<br>
                -p number &nbsp;Runs tests in parallel with a given number of threads<br>
                -f filter &nbsp;A filter applied to the beginning of the test names<br>
                -n name &nbsp;&nbsp; A certain test to be run superseding the name filter<br>
                -t timeout  A timeout in seconds for tests without local timeouts<br>
                -o xmlfile  The XML output file name (default: libunittest.xml)
                </code>
                
                <a name="assertions"></a>
                <h2>Assertions</h2>
                <p>
                libunittest comes with a rich set of assertions that your
                test has automatic access to. All assertions are
                implemented and documented in <incode>libunittest/assertions.hpp</incode>.
                </p>
                <p>
                The top-five, probably most used assertions are (in pseudo-code):
                <code>
                assert_true(value, message...);
                </code>
                <code>
                assert_equal(expected, actual, message...);
                </code>
                <code>
                assert_approx_equal(expected, actual, epsilon, message...);
                </code>
                <code>
                assert_in_container(element, container, message...);
                </code>
                <code>
                assert_throw&lt;exception_type&gt;(functor, message...);
                </code>
                
				Please note that <incode>message...</incode> denotes 
				a variable number of template parameters (variadic 
				template) and can also be omitted. If given 
				it is appended to the default fail message.
                </p>

				<a name="random"></a>
                <h2>Random values and containers</h2>
                <p>
                
				Using random functionality can be a convenient way 
				of generating test data. libunittest provides 
				easy-to-use classes to generate random values and 
				containers. All random stuff can be found in 
				<incode>libunittest/random.hpp</incode>. All random classes
				have a common abstract base class called <incode>random_object</incode>
				which has a simple public interface (in pseudo code):
				<li>
					<incode>seed(value)</incode> - Let's you set a new random seed. The default seed is 1.
				</li>
                
				<li>
					<incode>get()</incode> - Returns a new random value or container at every call and is implemented by every deriving class. 
				</li>
                </p>
                <p>
					Let's check out an example:
					<code>
						auto random = unittest::make_random_value&lt;int&gt;(10); <br>
						random.seed(42); // let's you set the random seed (default is 1)<br>
						int rand_value1 = random.get(); // a random int in [0, 10]<br>
						int rand_value2 = random.get(); // another random int in [0, 10]<br>
					</code>
                </p>
                
                <p>
				Here's an overview of the random classes (in pseudo code) with brief descriptions:
				<li>
					<incode>random_value&lt;T&gt;</incode> 
					represents a random value where <incode>T</incode> 
					can be something like <incode>int</incode>, 
					<incode>double</incode>, or <incode>bool</incode>. Available constructors
					are:
					<code>
						random_value() // value between 0 and 1 <br>
						random_value(maximum) // value between 0 and max <br>
						random_value(minimum, maximum) // value between min and max <br>
					</code>
					The corresponding factory functions are:
					<code>
						make_random_value&lt;T&gt;(...)
					</code>
				</li>
                
				<li>
					<incode>random_choice&lt;Container&gt;</incode> let's you pick a random element from a given container 
					such as <incode>std::vector</incode> or <incode>std::list</incode>. The available constructor is:
					<code>
						random_choice(container)
					</code>
					The corresponding factory function is:
					<code>
						make_random_choice(container)
					</code>
				</li>
                
				<li>
					<incode>random_container&lt;Container&gt;</incode> 
					generates a random container from a given random object.
					Available constructors are:
					<code>
						random_container(random_object, size)
						random_container(random_object, min_size, max_size) 
					</code>
					The corresponding factory functions are:
					<code>
						make_random_container(...) <br>
						make_random_vector(...) // for convenience
					</code>					
				</li>
                
                <li>
                    <incode>random_shuffle&lt;Container&gt;</incode> 
                    generates a shuffled version of a given container.
                    Available constructors are:
                    <code>
                        random_shuffle(container)<br>
                        random_shuffle(container, size) 
                    </code>
                    The corresponding factory functions are:
                    <code>
                        make_random_shuffle(...)
                    </code>                 
                </li>
                
                <li>
                    <incode>random_tuple&lt;Args...&gt;</incode> 
                    generates a random tuple from given random objects.
                    Available constructor is:
                    <code>
                        random_tuple(random_objects...)
                    </code>
                    The corresponding factory function is:
                    <code>
                        make_random_tuple(random_objects...)
                    </code>                 
                </li>
                
                <li>
                    <incode>random_pair&lt;F,S&gt;</incode> 
                    generates a random pair from two random objects.
                    Available constructor is:
                    <code>
                        random_pair(random_object1, random_object2)
                    </code>
                    The corresponding factory function is:
                    <code>
                        make_random_pair(random_object1, random_object2)
                    </code>                 
                </li>
                
				<li>
					<incode>random_combination&lt;Container1, Container2&gt;</incode>
					generates random pairs of two containers.
					Available constructor is:
					<code>
						random_combination(container1, container2, size)<br>
					</code>
					The corresponding factory function is:
					<code>
						make_random_combination(container1, container2, size) 
					</code>					
				</li>
                
                </p>

				<a name="output"></a>
                <h2>Customizing output</h2>
                <p>
					There are a few ways of custimizing the output
					of test runs in libunittest. First of all, your
					compiled test application comes with a help section
					that you can trigger by:
					<code>
						./test_application -h
					</code> This will show you how to run tests in 
					verbose mode, how to enable XML output, etc.

					</code>
                </p>

				<p>
				
				<incode>unittest::testcase</incode> comes with a few 
				virtual methods which somewhat control the output on test fail and error (in pseudo code):
				<code>
					string make_displayed_fail_message(assertion, text);<br>
					int max_displayed_string_length();<br>
					int max_displayed_value_precision();<br>
				</code>
				Simply override these methods in your test class.
				
				</p>
				
				<p>
				
				Last but not least, you can go ahead and write your own
				environment function that you would call in your main 
				file instead of <incode>unittest::process()</incode>. Check out 
				<incode>libunittest/environments.hpp</incode> and 
				<incode>src/environments.cpp</incode> to see how 
				the implementation looks like today.
				
				</p>

				<a name="miscellaneous"></a>
                <h2>Miscellaneous</h2>
                <p>
				<li>
					You can run test cases in parallel by typing:
					<code>
						./test_application -p number
					</code> 
					where number denotes the number of concurrent threads to use.
				</li>
				<li>
					There is a very useful function, namely <incode>unittest::join(arg, args...)</incode>, 
					which joins an arbitrary number of arguments of arbitrary type to a single string.
				</li>
				<li>
				    The macro <incode>UNITTEST_TESTINFO</incode> (or shortcut <incode>TESTINFO</incode>)
				    lets you log information about the current test. Just do something like
				    <code>
				        TEST(test_number_greater_zero)<br> 
				        {<br> 
				            <t>int number = 42;</t><br>  
				            <t>TESTINFO("Check for number greater than zero: ", number)</t><br> 
				            <t>assert_greater(number, 0, SPOT);</t><br> 
				        }
				    </code>
				    This will output the given test info to the
                    output XML and to standard out in case of fails and errors.
                    Note: Only use one <incode>TESTINFO</incode> macro per test and make sure
                    it's at the beginning before stuff may go wrong.
				</li>
				<li>
					You can find a collection of strings useful for testing under the
					namespace <incode>unittest::strings</incode> and defined in the
					file <incode>libunittest/strings.hpp</incode>.
				</li>
				<li>
					Internal functionality important for the libunittest
					core but not relevant for most users can be found
					under the namespace <incode>unittest::internals</incode>.
				</li>

				</p>

				<a name="developer"></a>
                <h2>Developer notes</h2>
                <p>
					If you'd like to contribute to libunittest then 
					this section will be interesting for you. First 
					you'd want to <a href="http://sourceforge.net/p/libunittest/code/ci/master/tree" target="_blank">check out</a> the code.
                </p>
                <p>
					In order to build and install please have a look at the <a href="installation.html">installation instructions</a>.
                </p>
                <p>
					There are a few more targets the master <incode>Makefile</incode> provides:
					<li>

						<incode>make check</incode> - Performs a 
						complete library check. Builds the library, 
						builds and executes tests and examples and 
						compiles the doxygen documentation.

					</li>
					
					<li>

						<incode>make distcheck</incode> - Just like the 
						<incode>check</incode> target but builds a source distribution first.

					</li>

					<li>

						<incode>make version</incode> - Generates a new version file in case the version was incremented.

					</li>

					<li>

						<incode>make dist</incode> - Builds a source distribution.

					</li>
                
					<li>

						<incode>make deb</incode> - Builds a debian package.

					</li>
                
					<li>

						<incode>make clean</incode> - Major clean-up.

					</li>
                
                </p>
                
                <p>
					Whether you're developing a new feature or 
					fixing a bug, please always and in any case make 
					sure you test the stuff you're writing. You can 
					easily add your tests to the existing test 
					suite. Also consider providing an example on how 
					to use your new feature. And finally, you're 
					code is only complete if it is properly documented.
                </p>
	</div>
</body>
</html>
