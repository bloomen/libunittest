<!DOCTYPE HTML>
<html>
<head>
	<meta charset="UTF-8">
	<title>libunittest C++ library</title>
	<link rel="stylesheet" href="css/style.css" type="text/css">
</head>
<body>
	<div id="header">
		<div>
			<ul id="navigation">
				<li>
					<a href="index.html">Home</a>
				</li>
				<li>
					<a href="installation.html">Installation</a>
				</li>
				<li class="active">
					<a href="tutorial.html">Tutorial</a>
				</li>
				<li>
					<a href="downloads.html">Downloads</a>
				</li>
				<li>
					<a href="feedback.html">Feedback</a>
				</li>
			</ul>
		</div>
	</div>
	<div id="contents">
			<h1>Tutorial</h1>
				<p> This tutorial provides you with a quick 
				introduction to libunittest. Please also check out 
				the examples that are shipped with libunittest. </p>
			
				<p>
				<li>
					<a href="#assembling">Assembling a test project</a>
				</li>
				<li>
					<a href="#assertions">Assertions</a>
				</li>
				<li>
					<a href="#fixtures">Fixtures and test contexts</a>
				</li>
				<li>
					<a href="#random">Random values and containers</a>
				</li>
				<li>
					<a href="#output">Customizing output</a>
				</li>
				<li>
					<a href="#developer">Developer notes</a>
				</li>
				</p>
			
				<a name="assembling"></a>
                <h2>Assembling a test project</h2>
                <p>
                The first thing you'll need is a <incode>main.cpp</incode> file 
                which should look like this:
                <code>
                    // main.cpp <br>
                    #include &lt;libunittest/unittest.hpp&gt;<br></br>
                    int main(int argc, char **argv) {<br>
                    <t>return unittest::process(argc, argv);</t><br>
                    }
                </code>
                Everything coming from libunittest lives within the 
                <incode>unittest</incode> namespace. Next you'll need another
                source file possibly called <incode>testcases.cpp</incode> which
                contains a list of calls to your test cases:
                <code>
                    // testcases.cpp <br>
                    #include "test_whatever.h"<br><br>

                    void unittest::run_all_tests() {<br>
                    <t>unittest::call&lt;test_whatever&gt;();</t><br>
                    }
                </code>
                This runs all tests assigned to the test class 
                <incode>test_whatever</incode>. As you can see, <incode>unittest::run_all_tests()</incode> must
                be implemented by the user. This may seem tedious at first but
                this explicit test registration leaves the freedom to run certain
                tests in parallel using all cores on your machine.
                Let's have a look at how <incode>test_whatever.h</incode> may look like:
                <code>
                    // test_whatever.h <br>
                    #pragma once<br>
                    #include &lt;libunittest/unittest.hpp&gt;<br><br>
                    struct test_whatever : unittest::testcase<> {<br><br>

                        <t>// this static method runs the tests</t><br>
                        <t>static void run() {</t><br>
                            <tt>UNITTEST_CLASS(test_whatever)</tt> // must appear first<br> 
                            <tt>UNITTEST_RUN(test_throw)</tt><br>
                            <tt>UNITTEST_RUN(test_in_range)</tt><br>
                            <tt>UNITTEST_RUN_TIME(test_in_container, 2)</tt> // with timeout<br>
                        <t>}</t><br><br>

                        <t>void test_in_container();</t><br>
                        <t>void test_in_range();</t><br>
                        <t>void test_throw();</t><br>
                    };
                </code>

				Quite simple right? All macros are defined in 
				capital letters and start with <incode>UNITTEST</incode>. 
				They can be found in <incode> 
				libunittest/macros.hpp</incode>. The test 
				implementation should be put in a separate file 
				called <incode>test_whatever.cpp</incode>:
                <code>
                    // test_whatever.cpp <br>
                    #include "test_whatever.h"<br>
					#define SPOT UNITTEST_SPOT<br><br>

					void test_whatever::test_in_container() {<br>
						<t>auto container = my_awesome_function();</t><br>
						<t>auto element = 3.14;</t><br>
						<t>assert_in_container(element, container, SPOT);</t><br>
					}<br><br>
					
					...
				</code> Here it is asserted that the number <incode>3.14</incode> is 
				found in the container returned from the function to 
				test. The macro <incode>UNITTEST_SPOT</incode> 
				defines a simple string containing information about 
				the current file and line number.
                </p>
                
                <a name="assertions"></a>
                <h2>Assertions</h2>
                <p>
                libunittest comes with a rich set of assertions that your
                test class has automatic access to once it derives from
                <incode>unittest::testcase</incode>. All assertions are
                implemented and documented in <incode>libunittest/assertions.hpp</incode>.
                </p>
                <p>
                The top-five, probably most used assertions are (in pseudo-code):
                <code>
                assert_true(value, message...);
                </code>
                <code>
                assert_equal(expected, actual, message...);
                </code>
                <code>
                assert_approx_equal(expected, actual, epsilon, message...);
                </code>
                <code>
                assert_in_container(element, container, message...);
                </code>
                <code>
                assert_throw&lt;exception_type&gt;(functor, message...);
                </code>
                
				Please note that <incode>message...</incode> denotes 
				a variable number of template parameters (variadic 
				template) and can also be omitted. If given 
				it is appended to the default fail message.
                </p>

				<a name="fixtures"></a>
                <h2>Fixtures and test contexts</h2>
                
				<p> Test fixtures are certain ressources that tests
				can rely on. Fixtures often make an explicit clean-up 
				step necessary. In libunittest there are two 
				different ways of defining fixtures which can even 
				be combined: </p>
				
				<br>
				<p> 1) <b>Regular fixtures</b> defined within the test 
				class. Set up and tear down are executed before and 
				after each test. </p>

				<p> A regular fixture can via defined via overriding 
				<incode>set_up()</incode> and <incode>tear_down()</incode> 
				methods or via explicit constructor and 
				destructor of the test class itself. Which way you 
				choose is kind of a matter of taste. However, here's 
				how you'd do it the recommended way:
				
				<code>
				#pragma once<br>
				#include &lt;libunittest/unittest.hpp&gt;<br><br>

				// A test class with a regular fixture <br>
				struct my_test : unittest::testcase<> { <br><br>

					<t>static void run() {</t><br>
                        <tt>UNITTEST_CLASS(my_test)</tt><br> 
                        <tt>UNITTEST_RUN(test_something)</tt><br>
                        <tt>UNITTEST_RUN(test_something_else)</tt><br>
					<t>}</t><br><br>

					<t>my_test() {</t> <br>
						<tt>std::fill(data_.begin(), data_.end(), 42);</tt><br>
					<t>}</t><br><br>
				
					<t>~my_test() {</t><br>
						<tt>data_.clear();</tt><br>					
					<t>}</t><br><br>

					<t>void test_something();</t><br>
					<t>void test_something_else();</t><br><br>
				
				private:<br>
					<t>std::vector&lt;int&gt; data_(10);</t><br>
				};
				</code>
				
				</p>

				<br>
				<p>
				2) <b>Test contexts</b> whose instances are shared by multiple tests. 
				</p>
				<p>
				Tests should be as independent as possible. However, 
				in some cases setting up a regular fixture for every 
				test can be an expensive task. Therefore, 
				libunittest supports the idea of test contexts. A 
				test context is only instantiated once and can then be 
				used by multiple tests. Here's how you do it:
				<code>
				#pragma once<br>
				#include &lt;libunittest/unittest.hpp&gt;<br><br>
				
				struct test_context { <br><br>

					<t>test_context() {</t> <br>
						<tt>std::fill(data_.begin(), data_.end(), 42);</tt><br>
					<t>}</t><br><br>
				
					<t>~test_context() {</t><br> 
						<tt>data_.clear();</tt><br>					
					<t>}</t><br><br>

					<t>std::vector&lt;int&gt;&amp; get_data() const {</t><br>
						<tt>return data_;</tt><br>
					<t>}</t><br><br>
					
				private:<br>
					<t>std::vector&lt;int&gt; data_(1000000);</t><br>
				};<br><br>
					
				// A test class with a test context <br>
				struct my_test : unittest::testcase&lt;test_context&gt; { <br><br>

					<t>static void run() {</t><br>
                        <tt>UNITTEST_CLASS(my_test)</tt><br> 
                        <tt>test_context context;</tt><br> 
                        <tt>UNITTEST_RUNCXT(context, test_something)</tt><br>
                        <tt>UNITTEST_RUNCXT(context, test_something_else)</tt><br>
					<t>}</t><br><br>

					<t>void test_something() {</t><br>
							<tt>auto context = get_test_context();</tt> // pointer to context<br>
							<tt>assert_equal(1000000, context->get_data().size());</tt><br>
					<t>}</t><br><br>

					<t>void test_something_else();</t><br>
				};
				</code>

				It is important to define a possible tear down  of 
				the test context using the destructor to ensure 
				proper clean up (explicit destructor not necessary 
				here due to RAII). The test context can also be 
				passed through <incode>run()</incode> and then be 
				shared by multiple test cases.  </p>

				<p>
				
				I would recommend to always start off with regular 
				fixtures. If those become too expensive move on to 
				test contexts but try to avoid side-effects between 
				tests. You can also always combine regular fixures 
				with test contexts.
				
				</p>

				<a name="random"></a>
                <h2>Random values and containers</h2>
                <p>
                
				Using random functionality can be a convenient way 
				of generating test data. libunittest provides 
				easy-to-use classes to generate random values and 
				containers. All random stuff can be found in 
				<incode>libunittest/random.hpp</incode>. All random classes
				have a common abstract base class called <incode>random_object</incode>
				which has a simple public interface (in pseudo code):
				<li>
					<incode>seed(value)</incode> - Let's you set a new random seed. The default seed is 1.
				</li>
                
				<li>
					<incode>get()</incode> - Returns a new random value or container at every call and is implemented by every deriving class. 
				</li>
                </p>
                <p>
					Let's check out an example:
					<code>
						auto random = unittest::make_random_value&lt;int&gt;(10); <br>
						random.seed(42); // let's you set the random seed (default is 1)<br>
						int rand_value1 = random.get(); // a random int in [0, 10]<br>
						int rand_value2 = random.get(); // another random int in [0, 10]<br>
					</code>
                </p>
                
                <p>
				Here's an overview of the random classes (in pseudo code) with brief descriptions:
				<li>
					<incode>random_value&lt;T&gt;</incode> 
					represents a random value where <incode>T</incode> 
					can be something like <incode>int</incode>, 
					<incode>double</incode>, or <incode>bool</incode>. Available constructors
					are:
					<code>
						random_value() // value between 0 and 1 <br>
						random_value(maximum) // value between 0 and max <br>
						random_value(minimum, maximum) // value between min and max <br>
					</code>
					The corresponding factory functions are:
					<code>
						make_random_value&lt;T&gt;(...)
					</code>
				</li>
                
				<li>
					<incode>random_choice&lt;Container&gt;</incode> let's you pick a random element from a given container 
					such as <incode>std::vector</incode> or <incode>std::list</incode>. The available constructor is:
					<code>
						random_choice(container)
					</code>
					The corresponding factory function is:
					<code>
						make_random_choice(container)
					</code>
				</li>
                
				<li>
					<incode>random_container&lt;Container&gt;</incode> 
					generates a random container from a given random object.
					Available constructors are:
					<code>
						random_container(random_object, size)
						random_container(random_object, min_size, max_size) 
					</code>
					The corresponding factory functions are:
					<code>
						make_random_container(...) <br>
						make_random_vector(...) // for convenience
					</code>					
				</li>
                
				<li>
					<incode>random_shuffle&lt;Container&gt;</incode> 
					generates a shuffled version of a given container.
					Available constructors are:
					<code>
						random_shuffle(container)<br>
						random_shuffle(container, size) 
					</code>
					The corresponding factory functions are:
					<code>
						make_random_shuffle(...)
					</code>					
				</li>
                
				<li>
					<incode>random_combination&lt;Container1, Container2&gt;</incode>
					generates random pairs of two containers.
					Available constructor is:
					<code>
						random_combination(container1, container2, size)<br>
					</code>
					The corresponding factory function is:
					<code>
						make_random_combination(container1, container2, size) 
					</code>					
				</li>
                
                </p>

				<a name="output"></a>
                <h2>Customizing output</h2>
                <p>
					There are a few ways of custimizing the output
					of test runs in libunittest. First of all, your
					compiled test application comes with a help section
					that you can trigger by:
					<code>
						./test_application -h
					</code> This will show you how to run tests in 
					verbose mode, how to enable XML output, etc.

					</code>
                </p>

				<p>
				
				<incode>unittest::testcase</incode> comes with a few 
				virtual methods which somewhat control the output on test fail and error (in pseudo code):
				<code>
					string make_displayed_fail_message(assertion, text);<br>
					int max_displayed_string_length();<br>
					int max_displayed_value_precision();<br>
				</code>
				Simply override these methods in your test class.
				
				</p>
				
				<p>
				
				Last but not least, you can go ahead and write your own
				environment function that you would call in your main 
				file instead of <incode>unittest::process()</incode>. Check out 
				<incode>libunittest/environments.hpp</incode> to see how 
				the implementation looks like today.
				
				</p>

				<a name="developer"></a>
                <h2>Developer notes</h2>
                <p>
					If you'd like to contribute to libunittest then 
					this section will be interesting for you. First 
					you'd want to <a href="http://sourceforge.net/p/libunittest/code/ci/master/tree" target="_blank">check out</a> the code.
                </p>
                <p>
					In order to build and install please have a look at the <a href="installation.html">installation instructions.</a>
                </p>
                <p>
					There are a few more targets the master <incode>Makefile</incode> provides:
					<li>

						<incode>make check</incode> - Performs a 
						complete library check. Builds the library, 
						builds and executes tests and examples and 
						compiles the doxygen documentation.

					</li>
					
					<li>

						<incode>make distcheck</incode> - Just like the 
						<incode>check</incode> target but builds a source distribution first.

					</li>

					<li>

						<incode>make version</incode> - Generates a new version file in case the version was incremented.

					</li>

					<li>

						<incode>make dist</incode> - Builds a source distribution.

					</li>
                
					<li>

						<incode>make deb</incode> - Builds a debian package.

					</li>
                
					<li>

						<incode>make clean</incode> - Major clean-up.

					</li>
                
                </p>
                
                <p>
					Whether you're developing a new feature or 
					fixing a bug, please always and in any case make 
					sure you test the stuff you're writing. You can 
					easily add your tests to the existing test 
					suite. Also consider providing an example on how 
					to use your new feature. And finally, you're 
					code is only complete if it is properly documented.
                </p>
	</div>
</body>
</html>
